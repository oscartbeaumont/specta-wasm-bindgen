use std::time::SystemTime;

use specta::{Type, TypeCollection, function};
use wasm_bindgen::prelude::*;

#[derive(Type)]
pub struct Testing {}

#[wasm_bindgen]
pub struct A {
    a: String,
    b: String,
    c: SystemTime,
}

#[wasm_bindgen]
impl A {
    pub fn todo(&self) {}

    pub fn todo2(&self) -> A {
        todo!()
    }
    // pub fn todo3(&self) -> SystemTime {
    //     todo!()
    // }
}

// We can't have `pub` `specta::specta` function in the root module. Same problem as Tauri has with command :(
mod commands {
    use super::*;

    // #[specta_wasm_bindgen::expose]
    // pub fn my_function(name: &str) -> i32 {
    //     42
    // }

    // Would expand to:
    #[specta::specta]
    pub fn my_function(name: &str) -> i32 {
        42
    }

    #[wasm_bindgen(js_name = "my_function")]
    pub fn my_function_wasm(name: &str) -> JsValue {
        serde_wasm_bindgen::to_value(&my_function(name)).unwrap()
    }

    // Some `ctor` collection code like Specta export.
}

// TODO: Do this within `specta-bindgen` crate.
#[wasm_bindgen]
pub fn export_specta_types() -> String {
    let mut types = TypeCollection::default();
    let functions = function::collect_functions![commands::my_function](&mut types);

    let mut out = format!("// Generated by specta-bindgen\n\n");

    // TODO: Configure `pkg` path or export into it?

    for function in functions {
        out.push_str(&format!(
            "import {{ {0} as __original_{0} }} from './pkg';\n\n",
            function.name(),
        ));
        out.push_str(&format!(
            "export function {}({}): {} {{\n    return __original_{}({});\n}}\n",
            function.name(),
            function
                .args()
                .map(|(a, b)| format!(
                    "{a}: {}",
                    specta_typescript::datatype(
                        &Default::default(),
                        &specta::datatype::FunctionResultVariant::Value(b.clone()),
                        &types
                    )
                    .unwrap(),
                ))
                .collect::<Vec<_>>()
                .join(", "),
            // TODO: Reuse `Typescript` instance
            specta_typescript::datatype(&Default::default(), function.result().unwrap(), &types)
                .unwrap(),
            function.name(),
            function
                .args()
                .map(|(a, b)| a.clone())
                .collect::<Vec<_>>()
                .join(", "),
        ));
    }

    out.push_str(
        &specta_typescript::Typescript::default()
            .export(&types)
            .unwrap(),
    );

    out
}
